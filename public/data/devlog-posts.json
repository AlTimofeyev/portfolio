[
    {
        "year": "2024",
        "month": "April",
        "day": "1",
        "project": "Portfolio Website",
        "subject": "Transition to Portfolio v2.0",
        "links": {
            "githubLink": "https://github.com/AlTimofeyev/portfolio"
        },
        "summary": [
            "The transition to portfolio V2.0 includes some new layouts, a unified color scheme, ",
            "additional development progress and contact pages, and better navigation. ",
            "There's also some animated compenents, which were implemented using GreenSock's ",
            "GSAP javascript animation library."
        ],
        "content": [
            {
                "title": "Navigation",
                "desc": [
                    {
                        "paragraphBlock": [
                            "The current navbar navigation is handled using HashRouter becuase BrowserRouter ",
                            "is not capable of handling page routing with GitHub Pages. ",
                            "As of this current update to the website, the browser back/forward navigation ",
                            "buttons break the active navbar link. I will need to figure out how to implement ",
                            "browser history in the next iteration of the website. For now, I used a quick-fix ",
                            "solution to this problem, where each individual page will set the active navbar link ",
                            "by using a navbar Context to save and load the active navbar link from local storage. ",
                            "Opening a link via CMD + <click> or CTRL + <click> still breaks the active navbar link though."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "As a quick note, it will probalby be best to save the navbar information to session ",
                            "storage instead of local storage. Session storage get's wiped when the user leaves the ",
                            "page while the local storage will persist. The local storage ends up breaking the navbar ",
                            "active link as well, when the user revisits the page. The quick-fix solution is a temporary ",
                            "fix for this issue at the moment."
                        ]
                    }
                ]
            },
            {
                "title": "Devlog Posts",
                "desc": [
                    {
                        "paragraphBlock": [
                            "The current content for all the devlogs on the Devlog page is stored in a JSON file and ",
                            "mapped onto HTML elements. There is possibly an easier way to do this, maybe storing the ",
                            "information in a proper database solution, but for now this works just fine."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "There is an issue to consider though: What happens when there are too many devlog posts. ",
                            "If there are too many posts to show from the devlog JSON file, this might slow down the browser, ",
                            "or slow down the loading of the devlog posts onto the page. To avoid this issue, I'll need ",
                            "to look into some sort of loading option where initially only a certain amount of devlog posts ",
                            "are loaded up (like 10) and as the user scrolls down the page, more devlog posts begin loading. ",
                            "This approach is similar to how most social media platforms function."
                        ]
                    }
                ]
            },
            {
                "title": "Color Scheme",
                "desc": [
                    {
                        "paragraphBlock": [
                            "The color scheme (color MODE) is set with the help of React Context. The default color scheme ",
                            "is <Light Mode> and is defined in the App.scss file. Upon page-load, the color scheme choice ",
                            "is saved into the browser's Local Storage. If the user decided to change the color scheme, the ",
                            "Context updates the user's choice via the Context and saved the user's choice to Local Storage. ",
                            "This way, if the user visits the page again, or if the user reloads the page, the color scheme ",
                            "they previously chose is loaded from Local Storage."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "I origianlly tried to use SCSS to create variables for the two different color schemes. Unfortunately, ",
                            "I wasn't able to identify how to modify SCSS variables through the React Context and was made ",
                            "aware that the SCSS compiler thows away variables that are not used at runtime. I don't know what ",
                            "it means by 'throws away variables' at the moment, so I decided to go with pure CSS variables ",
                            "for this occasion to avoid any mishaps. I'll need to do a bit more searching in this area when ",
                            "I update my portfolio in the future."
                        ]
                    }
                ]
            },
            {
                "title": "Assets",
                "desc": [
                    {
                        "paragraphBlock": [
                            "Some of the icons were used from FontAwesome. However, the majority of the assets and ",
                            "icons were hand-drawn by me. Since some of the icons supplied by FontAwesome were not centered ",
                            "uniformly (from icon to icon), I had to draw most of the icons by hand using Procreate, export ",
                            "the icons in PNG format and then convert them to SVG format using a website called convertio.co ",
                            "before import them into my React project. Upon importing the icons into my React project, it is ",
                            "important to not that a simple change needs to be made to each asset: Open the SVG files, one by one, ",
                            "and modify their <fill> and <stroke> fields to equal 'current'. This will allow for their fill ",
                            "and stroke attributes to be set via CSS."
                        ]
                    }
                ]
            },
            {
                "title": "GSAP Animations",
                "desc": [
                    {
                        "paragraphBlock": [
                            "All of the animations on the page are created using GreenSock's GSAP library. For React, it ",
                            "is good to note that GSAP animations should be defined in a funciton called <gsap.context>. ",
                            "This context allows for clean animation definitions and animation timeline creation using React ",
                            "Reference Hooks, followed by a cleanup function called <revert> for each GSAP context upon leaving ",
                            "the area they were defined in. It is also good to note that these GSAP contexts are better to ",
                            "be defined in React's <useEffect> as it allows you to call the cleanup <revert> funtion in it's ",
                            "return statement. Another good thing to note is that, if you are using React Reference Hooks inside ",
                            "GSAP context, then you can reference anything within the parent element of the React Reference Hook ",
                            "using CSS. Example: '.devlog-post-container' or '.section-title' and etc."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "GSAP also has a way to define animations for specific screen sizes. You can use the GSAP <gsap.matchMedia> ",
                            "function to define animations for a number of media options. GSAP's <gsap.matchMedia> function ",
                            "acts the same way that GSAP's <gsap.context> function acts. It is important to note that, since ",
                            "<gsap.matchMedia> functions the same way as a <gsap.context>, you don't need to use <gsap.context> ",
                            "inside of <gsap.matchMedia> because it already functions like a GSAP conext. If I'm going to use ",
                            "more complex animations in the future, I'll need to do more research into the finer details of <gsap.context> ",
                            "and <gsap.matchMedia>, as well as any other options that GSAP offers for React applications."
                        ]
                    }
                ]
            }
        ]
    },
    {
        "year": "2023",
        "month": "April",
        "day": "7",
        "project": "Python Palette Extractor (PyPalEx)",
        "subject": "Published v1.3.3 of PyPalEx",
        "links": {
            "githubLink": "https://github.com/AlTimofeyev/pypalex",
            "pypiLink": "https://pypi.org/project/pypalex/"
        },
        "summary": [
            "This log contains updates to the saving options, extraction options, the Extractor ",
            "class, as well as the extraction process itself. Since this is the first post for ",
            "this project, the updates listed in this devlog will contain details from v1.3.0 up to ",
            "v1.3.3."
        ],
        "content": [
            {
                "title": "Extraction Process",
                "desc": [
                    {
                        "paragraphBlock": [
                            "The extraction process has been optimized to focus on single image files rather than ",
                            "focusing on multiple image files. What this means is that, instead of utilizing multi-processing ",
                            "to extract from multiple images at the same time, multi-processing will now be used ",
                            "to extract multiple colors from a single image at the same time. This approach decreases ",
                            "the amount of time that it takes to extract color palettes from images and normalizes it to ",
                            "about ~5 seconds per image. This inadvertently also decreased the amount of time for extracting ",
                            "color palettes from multiple images. You can now calculate exactly how much time it will take ",
                            "to extract colors from images by multiplying 5 seconds by the number of images."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "Example: You have 10 images you would like to extract from. So the total wait-time for the ",
                            "completion of the extraction process would be 5 seconds x 10 images = ~50 seconds."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "The extraction process also differs from that of versions prior to v1.3.0. The eariler method ",
                            "for extracting colors had a mojority of the process be randomized while the current version ",
                            "focuses more on a mathematical and algorithmic approach akin to K-Means Clustering. Although ",
                            "the current algorithmic extraction process is not exactly like K-Means, it does borrow some ",
                            "concepts from K-Means, like using the average of a cluster of colors as a result for each extracted color. ",
                            "This approach does have some downsides though, becuase it doesn't account for the noise in color data ",
                            "where some outlying colors in a cluster may skew the average of that cluster and result in an ",
                            "inadequate color being extracted. The next approach to this problem will borrow concepts to DBSCAN, which ",
                            "accounts for having noise in the data clusters. The DBSCAN algorithm does have a tricky variable to deal with, ",
                            "called epsilon, so a Hierarchical DBSCAN using something like an Octree should be the desired approach."
                        ]
                    }
                ]
            },
            {
                "title": "Extractor Class",
                "desc": [
                    {
                        "paragraphBlock": [
                            "The Extractor Class has been modified so that it no longer organizes the extracted color palettes. ",
                            "The idea is for the Extractor Class to only be responsible for utilizing extraction utilities and ",
                            "algorithms and output the raw result in a dictionary for the user to use. This is to prepare the ",
                            "Extractor Class to be used as an importable class from the PyPalEx package, and to also act as a ",
                            "template for the user if they wish to make their own version of the Extractor Class that utilzes the ",
                            "provided extraction utilities and algorithms."
                        ]
                    }
                ]
            },
            {
                "title": "Additional Utility Files",
                "desc": [
                    {
                        "paragraphBlock": [
                            "There have been several utility files added in this update to manage different functions. The ",
                            "addition of a file_utils.py module will be responsible for managing how the extracted color ",
                            "palettes are saved in the user's computer system. The addition of a print_utils.py module will ",
                            "be responsible for the handling printing previews of the extracted color palettes to the user's ",
                            "terminal / CLI screen. These two modules are also possible collaboration points for open source ",
                            "contributors, Since everyone has different OS systems and file-saving preferences."
                        ]
                    }
                ]
            },
            {
                "title": "Additional Saving and Extraction Options",
                "desc": [
                    {
                        "paragraphBlock": [
                            "Several different saving and extraction options have also been added in this update."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "The user can now choose to extract more saturated colors via the `--sat-pref`, `--sat_pref-light`, ",
                            "`--sat_pref-normal` and `--sat_pref-dark` options. These options allow the user to extract more ",
                            "saturated colors from all three color palettes (light, normal, dark) or to choose a color palette ",
                            "specifically. Although the current saturation preference for these options is hard coded to 60% saturation, ",
                            "the next improvement for this option is to allow the user to decided the percentage they're looking for."
                        ]
                    },
                    {
                        "paragraphBlock": [
                            "The user can also now choose how they would like to proceed after the extraction process is complete by ",
                            "using `--save-check`, `--preview` and `--preview-check` options. The `--save-check` option allows the user ",
                            "to decided 'yes/no' if they want to save the extracted color palette. The `--preview` option allows the ",
                            "user to see a preview of the extracted color palette in the terminal before it is saved. And the `--preview-check` ",
                            "option is a combination of the previous two options, where it shows a preview of the extracted color palette ",
                            "to the user before asking them if they would like to have it saved."
                        ]
                    }
                ]
            }
        ]
    }
]